{"version":3,"file":null,"sources":["../src/angular.ts","../src/legacy/stateEvents.ts"],"sourcesContent":["/**\n * @hidden\n * @module ng1\n */ /** */\ndeclare var angular;\nimport * as ng_from_import from \"angular\";\nlet ng_from_global = angular;\n\nexport const ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n","/**\n * # Legacy state events\n *\n * Polyfill implementation of the UI-Router 0.2.x state events.\n *\n * The 0.2.x state events are deprecated.  We recommend moving to Transition Hooks instead, as they\n * provide much more flexibility, support async, and provide the context (the Transition, etc) necessary\n * to implement meaningful application behaviors.\n *\n * To enable these state events, include the `stateEvents.js` file in your project, e.g.,\n * ```\n * <script src=\"stateEvents.js\"></script>\n * ```\n * and also make sure you depend on the `ui.router.state.events` angular module, e.g.,\n * ```\n * angular.module(\"myApplication\", ['ui.router', 'ui.router.state.events']\n * ```\n *\n * @module ng1_state_events\n */ /** */\nimport { ng as angular } from \"../angular\";\nimport { IScope, IAngularEvent, IServiceProviderFactory } from \"angular\";\nimport {\n    Obj, TargetState, StateService, Transition, TransitionService, UrlRouter, HookResult, UIInjector\n} from \"@uirouter/core\";\nimport { StateProvider } from \"../stateProvider\";\n\n/**\n * An event broadcast on `$rootScope` when the state transition **begins**.\n *\n * ### Deprecation warning: use [[TransitionService.onStart]] instead\n *\n * You can use `event.preventDefault()`\n * to prevent the transition from happening and then the transition promise will be\n * rejected with a `'transition prevented'` value.\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]]\n *\n * #### Example:\n * ```js\n * $rootScope.$on('$stateChangeStart', function(event, transition) {\n *   event.preventDefault();\n *   // transitionTo() promise will be rejected with\n *   // a 'transition prevented' error\n * })\n * ```\n *\n * @event $stateChangeStart\n * @deprecated\n */\nexport var $stateChangeStart: IAngularEvent;\n\n/**\n * An event broadcast on `$rootScope` if a transition is **cancelled**.\n *\n * ### Deprecation warning: use [[TransitionService.onStart]] instead\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]] that was cancelled\n *\n * @event $stateChangeCancel\n * @deprecated\n */\nexport var $stateChangeCancel: IAngularEvent;\n\n/**\n * An event broadcast on `$rootScope` once the state transition is **complete**.\n *\n * ### Deprecation warning: use [[TransitionService.onStart]] and [[Transition.promise]], or [[Transition.onSuccess]]\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]] that just succeeded\n *\n * @event $stateChangeSuccess\n * @deprecated\n */\nexport var $stateChangeSuccess: IAngularEvent;\n\n/**\n * An event broadcast on `$rootScope` when an **error occurs** during transition.\n *\n * ### Deprecation warning: use [[TransitionService.onStart]] and [[Transition.promise]], or [[Transition.onError]]\n *\n * It's important to note that if you\n * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n * they will not throw traditionally. You must listen for this $stateChangeError event to\n * catch **ALL** errors.\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `error`: The reason the transition errored.\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]] that errored\n *\n * @event $stateChangeError\n * @deprecated\n */\nexport var $stateChangeError: IAngularEvent;\n\n/**\n * An event broadcast on `$rootScope` when a requested state **cannot be found** using the provided state name.\n *\n * ### Deprecation warning: use [[StateService.onInvalid]] instead\n *\n * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n * lazy-loading the unfound state). A `TargetState` object is passed to the listener handler,\n * you can see its properties in the example. You can use `event.preventDefault()` to abort the\n * transition and the promise returned from `transitionTo()` will be rejected with a\n * `'transition aborted'` error.\n *\n * Additional arguments to the event handler are provided:\n * - `unfoundState` Unfound State information. Contains: `to, toParams, options` properties.\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n *\n * #### Example:\n * ```js\n * // somewhere, assume lazy.state has not been defined\n * $state.go(\"lazy.state\", { a: 1, b: 2 }, { inherit: false });\n *\n * // somewhere else\n * $scope.$on('$stateNotFound', function(event, transition) {\n * function(event, unfoundState, fromState, fromParams){\n *     console.log(unfoundState.to); // \"lazy.state\"\n *     console.log(unfoundState.toParams); // {a:1, b:2}\n *     console.log(unfoundState.options); // {inherit:false} + default options\n * });\n * ```\n *\n * @event $stateNotFound\n * @deprecated\n */\nexport var $stateNotFound: IAngularEvent;\n\n\n(function () {\n  let { isFunction, isString } = angular;\n\n  function applyPairs(memo: Obj, keyValTuple: any[]) {\n    let key: string, value: any;\n    if (Array.isArray(keyValTuple)) [key, value] = keyValTuple;\n    if (!isString(key)) throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n  }\n\n  function stateChangeStartHandler($transition$: Transition) {\n    if (!$transition$.options().notify || !$transition$.valid() || $transition$.ignored())\n      return;\n\n    let $injector = $transition$.injector();\n    let $stateEvents = $injector.get('$stateEvents');\n    let $rootScope = $injector.get('$rootScope');\n    let $state = $injector.get('$state');\n    let $urlRouter = $injector.get('$urlRouter');\n\n    let enabledEvents = $stateEvents.provider.enabled();\n\n\n    let toParams = $transition$.params(\"to\");\n    let fromParams = $transition$.params(\"from\");\n\n    if (enabledEvents.$stateChangeSuccess) {\n      let startEvent = $rootScope.$broadcast('$stateChangeStart', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n\n      if (startEvent.defaultPrevented) {\n        if (enabledEvents.$stateChangeCancel) {\n          $rootScope.$broadcast('$stateChangeCancel', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n        }\n        //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n        if ($state.transition == null) $urlRouter.update();\n        return false;\n      }\n\n      // right after global state is updated\n      let successOpts = { priority: 9999 };\n      $transition$.onSuccess({}, function () {\n        $rootScope.$broadcast('$stateChangeSuccess', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n      }, successOpts);\n    }\n\n    if (enabledEvents.$stateChangeError) {\n      $transition$.promise[\"catch\"](function (error) {\n        if (error && (error.type === 2 /* RejectType.SUPERSEDED */ || error.type === 3 /* RejectType.ABORTED */))\n          return;\n\n\n        let evt = $rootScope.$broadcast('$stateChangeError', $transition$.to(), toParams, $transition$.from(), fromParams, error, $transition$.options(), $transition$);\n\n        if (!evt.defaultPrevented) {\n          $urlRouter.update();\n        }\n      });\n    }\n  }\n\n  stateNotFoundHandler.$inject = ['$to$', '$from$', '$state', '$rootScope', '$urlRouter'];\n  function stateNotFoundHandler($to$: TargetState, $from$: TargetState, injector: UIInjector): HookResult {\n    let $state: StateService = injector.get('$state');\n    let $rootScope: IScope = injector.get('$rootScope');\n    let $urlRouter: UrlRouter = injector.get('$urlRouter');\n\n    interface StateNotFoundEvent extends IAngularEvent {\n      retry: Promise<any>;\n    }\n\n    let redirect = { to: $to$.identifier(), toParams: $to$.params(), options: $to$.options() };\n    let e = <StateNotFoundEvent> $rootScope.$broadcast('$stateNotFound', redirect, $from$.state(), $from$.params());\n\n    if (e.defaultPrevented || e.retry)\n      $urlRouter.update();\n\n    function redirectFn(): TargetState {\n      return $state.target(redirect.to, redirect.toParams, redirect.options);\n    }\n\n    if (e.defaultPrevented) {\n      return false;\n    } else if (e.retry || !!$state.get(redirect.to)) {\n      return e.retry && isFunction(e.retry.then) ? e.retry.then(redirectFn) : redirectFn();\n    }\n  }\n\n  $StateEventsProvider.$inject = ['$stateProvider'];\n  function $StateEventsProvider($stateProvider: StateProvider) {\n    $StateEventsProvider.prototype.instance = this;\n\n    interface IEventsToggle {\n      [key: string]: boolean;\n      $stateChangeStart: boolean;\n      $stateNotFound: boolean;\n      $stateChangeSuccess: boolean;\n      $stateChangeError: boolean;\n    }\n\n    let runtime = false;\n    let allEvents = ['$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError'];\n    let enabledStateEvents = <IEventsToggle> allEvents.map(e => [e, true]).reduce(applyPairs, {});\n\n    function assertNotRuntime() {\n      if (runtime) throw new Error(\"Cannot enable events at runtime (use $stateEventsProvider\");\n    }\n\n    /**\n     * Enables the deprecated UI-Router 0.2.x State Events\n     * [ '$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError' ]\n     */\n    this.enable = function (...events: string[]) {\n      assertNotRuntime();\n      if (!events || !events.length) events = allEvents;\n      events.forEach(event => enabledStateEvents[event] = true);\n    };\n\n    /**\n     * Disables the deprecated UI-Router 0.2.x State Events\n     * [ '$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError' ]\n     */\n    this.disable = function (...events: string[]) {\n      assertNotRuntime();\n      if (!events || !events.length) events = allEvents;\n      events.forEach(event => delete enabledStateEvents[event]);\n    };\n\n    this.enabled = () => enabledStateEvents;\n\n    this.$get = $get;\n    $get.$inject = ['$transitions'];\n    function $get($transitions: TransitionService) {\n      runtime = true;\n\n      if (enabledStateEvents[\"$stateNotFound\"])\n        $stateProvider.onInvalid(stateNotFoundHandler);\n      if (enabledStateEvents.$stateChangeStart)\n        $transitions.onBefore({}, stateChangeStartHandler, { priority: 1000 });\n\n      return {\n        provider: $StateEventsProvider.prototype.instance\n      };\n    }\n  }\n\n\n  angular.module('ui.router.state.events', ['ui.router.state'])\n      .provider(\"$stateEvents\", <IServiceProviderFactory> $StateEventsProvider)\n      .run(['$stateEvents', function ($stateEvents: any) { /* Invokes $get() */\n      }]);\n})();\n"],"names":["ng_from_global","angular","ng","ng_from_import","ng_from_import.module","memo","keyValTuple","key","value","Array","isArray","isString","Error","$transition$","options","notify","valid","ignored","$injector","injector","$stateEvents","get","$rootScope","$state","$urlRouter","enabledEvents","provider","enabled","toParams","params","fromParams","$stateChangeSuccess","$broadcast","to","from","defaultPrevented","$stateChangeCancel","transition","update","successOpts","priority","onSuccess","$stateChangeError","promise","error","type","$to$","$from$","target","redirect","identifier","e","state","retry","isFunction","then","redirectFn","$stateProvider","runtime","$transitions","enabledStateEvents","onInvalid","stateNotFoundHandler","$stateChangeStart","onBefore","stateChangeStartHandler","$StateEventsProvider","prototype","instance","this","allEvents","map","reduce","applyPairs","enable","_i","events","assertNotRuntime","length","forEach","event","disable","$get","$inject","module","run","$stateNotFound"],"mappings":"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"}