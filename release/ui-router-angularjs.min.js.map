{"version":3,"file":null,"sources":["../src/statebuilders/views.ts","../src/templateFactory.ts","../src/services.ts","../src/directives/stateDirectives.ts","../src/stateFilters.ts","../src/directives/viewDirective.ts","../src/viewScroll.ts","../src/angular.ts","../src/stateProvider.ts","../src/statebuilders/onEnterExitRetain.ts","../src/locationServices.ts","../src/urlRouterProvider.ts","../src/index.ts"],"sourcesContent":["/** @module ng1 */ /** */\nimport { ng as angular } from \"../angular\";\nimport {\n    StateObject, pick, forEach, tail, extend,\n    isArray, isInjectable, isDefined, isString, services, trace,\n    ViewConfig, ViewService, ViewConfigFactory, PathNode, ResolveContext, Resolvable, IInjectable\n} from \"@uirouter/core\";\nimport { Ng1ViewDeclaration } from \"../interface\";\nimport { TemplateFactory } from \"../templateFactory\";\nimport IInjectorService = angular.auto.IInjectorService;\n\nexport function getNg1ViewConfigFactory(): ViewConfigFactory {\n  let templateFactory: TemplateFactory = null;\n  return (path, view) => {\n    templateFactory = templateFactory || services.$injector.get(\"$templateFactory\");\n    return [new Ng1ViewConfig(path, view, templateFactory)];\n  };\n}\n\nconst hasAnyKey = (keys, obj) =>\n    keys.reduce((acc, key) => acc || isDefined(obj[key]), false);\n\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n */\nexport function ng1ViewsBuilder(state: StateObject) {\n  // Do not process root state\n  if (!state.parent) return {};\n\n  let tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'],\n      ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'],\n      compKeys = ['component', 'bindings', 'componentProvider'],\n      nonCompKeys = tplKeys.concat(ctrlKeys),\n      allViewKeys = compKeys.concat(nonCompKeys);\n\n  // Do not allow a state to have both state-level props and also a `views: {}` property.\n  // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n  // However, the `$default` approach should not be mixed with a separate `views: ` block.\n  if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n    throw new Error(`State '${state.name}' has a 'views' object. ` +\n        `It cannot also have \"view properties\" at the state level.  ` +\n        `Move the following properties into a view (in the 'views' object): ` +\n        ` ${allViewKeys.filter(key => isDefined(state[key])).join(\", \")}`);\n  }\n\n  let views: { [key: string]: Ng1ViewDeclaration } = {},\n      viewsObject = state.views || { \"$default\": pick(state, allViewKeys) };\n\n  forEach(viewsObject, function (config: Ng1ViewDeclaration, name: string) {\n    // Account for views: { \"\": { template... } }\n    name = name || \"$default\";\n    // Account for views: { header: \"headerComponent\" }\n    if (isString(config)) config = { component: <string> config };\n\n    // Make a shallow copy of the config object\n    config = extend({}, config);\n\n    // Do not allow a view to mix props for component-style view with props for template/controller-style view\n    if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n      throw new Error(`Cannot combine: ${compKeys.join(\"|\")} with: ${nonCompKeys.join(\"|\")} in stateview: '${name}@${state.name}'`);\n    }\n\n    config.resolveAs = config.resolveAs || '$resolve';\n    config.$type = \"ng1\";\n    config.$context = state;\n    config.$name = name;\n\n    let normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);\n    config.$uiViewName = normalized.uiViewName;\n    config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\n    views[name] = config;\n  });\n  return views;\n}\n\nlet id = 0;\nexport class Ng1ViewConfig implements ViewConfig {\n  $id = id++;\n  loaded: boolean = false;\n  controller: Function; // actually IInjectable|string\n  template: string;\n  component: string;\n  locals: any; // TODO: delete me\n\n  constructor(public path: PathNode[], public viewDecl: Ng1ViewDeclaration, public factory: TemplateFactory) { }\n\n  load() {\n    let $q = services.$q;\n    let context = new ResolveContext(this.path);\n    let params = this.path.reduce((acc, node) => extend(acc, node.paramValues), {});\n\n    let promises: any = {\n      template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n      controller: $q.when(this.getController(context))\n    };\n\n    return $q.all(promises).then((results) => {\n      trace.traceViewServiceEvent(\"Loaded\", this);\n      this.controller = results.controller;\n      extend(this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n      return this;\n    });\n  }\n\n  getTemplate = (uiView, context: ResolveContext) =>\n    this.component ? this.factory.makeComponentTemplate(uiView, context, this.component, this.viewDecl.bindings) : this.template;\n\n  /**\n   * Gets the controller for a view configuration.\n   *\n   * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n   */\n  getController(context: ResolveContext): (IInjectable|string|Promise<IInjectable|string>) {\n    let provider = this.viewDecl.controllerProvider;\n    if (!isInjectable(provider)) return this.viewDecl.controller;\n    let deps = services.$injector.annotate(provider);\n    let providerFn = isArray(provider) ? tail(<any> provider) : provider;\n    let resolvable = new Resolvable(\"\", <any> providerFn, deps);\n    return resolvable.get(context);\n  }\n}\n","/** @module view */\n/** for typedoc */\nimport { ng as angular } from \"./angular\";\nimport { IAugmentedJQuery } from \"angular\";\nimport {\n  isArray, isDefined, isFunction, isObject, services, Obj, IInjectable, tail, kebobString, unnestR, ResolveContext,\n  Resolvable, RawParams\n} from \"@uirouter/core\";\nimport { Ng1ViewDeclaration, TemplateFactoryProvider } from \"./interface\";\n\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nexport class TemplateFactory implements TemplateFactoryProvider {\n  /** @hidden */ private _useHttp = angular.version.minor < 3;\n  /** @hidden */ private $templateRequest;\n  /** @hidden */ private $templateCache;\n  /** @hidden */ private $http;\n\n  /** @hidden */ $get = ['$http', '$templateCache', '$injector', ($http, $templateCache, $injector) => {\n    this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n    this.$http = $http;\n    this.$templateCache = $templateCache;\n    return this;\n  }];\n\n  /** @hidden */\n  useHttpService(value: boolean) {\n    this._useHttp = value;\n  };\n\n  /**\n   * Creates a template from a configuration object.\n   *\n   * @param config Configuration object for which to load a template.\n   * The following properties are search in the specified order, and the first one\n   * that is defined is used to create the template:\n   *\n   * @param params  Parameters to pass to the template function.\n   * @param context The resolve context associated with the template's view\n   *\n   * @return {string|object}  The template html as a string, or a promise for\n   * that string,or `null` if no template is configured.\n   */\n  fromConfig(config: Ng1ViewDeclaration, params: any, context: ResolveContext): Promise<{ template?: string, component?: string }> {\n    const defaultTemplate = \"<ui-view></ui-view>\";\n\n    const asTemplate  = (result) => services.$q.when(result).then(str => ({ template:  str }));\n    const asComponent = (result) => services.$q.when(result).then(str => ({ component: str }));\n\n    return (\n        isDefined(config.template)          ? asTemplate(this.fromString(config.template, params)) :\n        isDefined(config.templateUrl)       ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n        isDefined(config.templateProvider)  ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n        isDefined(config.component)         ? asComponent(config.component) :\n        isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n        asTemplate(defaultTemplate)\n    );\n  };\n\n  /**\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param template html template as a string or function that returns an html template as a string.\n   * @param params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that\n   * string.\n   */\n  fromString(template: (string | Function), params?: RawParams) {\n    return isFunction(template) ? (<any> template)(params) : template;\n  };\n\n  /**\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function\n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n  fromUrl(url: (string | Function), params: any) {\n    if (isFunction(url)) url = (<any> url)(params);\n    if (url == null) return null;\n\n    if (this._useHttp) {\n      return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n          .then(function (response) {\n            return response.data;\n          });\n    }\n\n    return this.$templateRequest(url);\n  };\n\n  /**\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n  fromProvider(provider: IInjectable, params: any, context: ResolveContext) {\n    let deps = services.$injector.annotate(provider);\n    let providerFn = isArray(provider) ? tail(<any[]> provider) : provider;\n    let resolvable = new Resolvable(\"\", <Function> providerFn, deps);\n    return resolvable.get(context);\n  };\n\n  /**\n   * Creates a component's template by invoking an injectable provider function.\n   *\n   * @param provider Function to invoke via `locals`\n   * @param {Function} injectFn a function used to invoke the template provider\n   * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n  fromComponentProvider(provider: IInjectable, params: any, context: ResolveContext) {\n    let deps = services.$injector.annotate(provider);\n    let providerFn = isArray(provider) ? tail(<any[]> provider) : provider;\n    let resolvable = new Resolvable(\"\", <Function> providerFn, deps);\n    return resolvable.get(context);\n  };\n\n  /**\n   * Creates a template from a component's name\n   *\n   * This implements route-to-component.\n   * It works by retrieving the component (directive) metadata from the injector.\n   * It analyses the component's bindings, then constructs a template that instantiates the component.\n   * The template wires input and output bindings to resolves or from the parent component.\n   *\n   * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n   * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n   * @param component {string} Component's name in camel case.\n   * @param bindings An object defining the component's bindings: {foo: '<'}\n   * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n  makeComponentTemplate(uiView: IAugmentedJQuery, context: ResolveContext, component: string, bindings?: any) {\n    bindings = bindings || {};\n\n    // Bind once prefix\n    const prefix = angular.version.minor >= 3 ? \"::\" : \"\";\n    // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n    const kebob = (camelCase: string) => {\n      const kebobed = kebobString(camelCase);\n      return /^(x|data)-/.exec(kebobed) ? `x-${kebobed}` : kebobed;\n    };\n\n\n    const attributeTpl = (input: BindingTuple) => {\n      let { name, type } = input;\n      let attrName = kebob(name);\n      // If the ui-view has an attribute which matches a binding on the routed component\n      // then pass that attribute through to the routed component template.\n      // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n      if (uiView.attr(attrName) && !bindings[name])\n        return `${attrName}='${uiView.attr(attrName)}'`;\n\n      let resolveName = bindings[name] || name;\n      // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n      // some-attr=\"{{ ::$resolve.someResolveName }}\"\n      if (type === '@')\n        return `${attrName}='{{${prefix}$resolve.${resolveName}}}'`;\n\n      // Wire \"&\" callbacks to resolves that return a callback function\n      // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n      // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n      if (type === '&') {\n        let res = context.getResolvable(resolveName);\n        let fn = res && res.data;\n        let args = fn && services.$injector.annotate(fn) || [];\n        // account for array style injection, i.e., ['foo', function(foo) {}]\n        let arrayIdxStr = isArray(fn) ? `[${fn.length - 1}]` : '';\n        return `${attrName}='$resolve.${resolveName}${arrayIdxStr}(${args.join(\",\")})'`;\n      }\n\n      // some-attr=\"::$resolve.someResolveName\"\n      return `${attrName}='${prefix}$resolve.${resolveName}'`;\n    };\n\n    let attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n    let kebobName = kebob(component);\n    return `<${kebobName} ${attrs}></${kebobName}>`;\n  };\n}\n\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name: string) {\n  let cmpDefs = <any[]> services.$injector.get(name + \"Directive\"); // could be multiple\n  if (!cmpDefs || !cmpDefs.length) throw new Error(`Unable to find component named '${name}'`);\n  return cmpDefs.map(getBindings).reduce(unnestR, []);\n}\n\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nconst getBindings = (def: any) => {\n  if (isObject(def.bindToController)) return scopeBindings(def.bindToController);\n  return scopeBindings(def.scope);\n};\n\ninterface BindingTuple {\n  name: string;\n  type: string;\n}\n\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nconst scopeBindings = (bindingsObj: Obj) => Object.keys(bindingsObj || {})\n    // [ 'input', [ '=foo', '=', 'foo' ] ]\n    .map(key => [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])])\n    // skip malformed values\n    .filter(tuple => isDefined(tuple) && isArray(tuple[1]))\n    // { name: ('foo' || 'input'), type: '=' }\n    .map(tuple => ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] } as BindingTuple));\n\n","/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @module ng1\n * @preferred\n */\n/** for typedoc */\nimport { ng as angular } from \"./angular\";\nimport {\n  IRootScopeService, IQService, ILocationService, ILocationProvider, IHttpService, ITemplateCacheService\n} from \"angular\";\nimport {\n  services, applyPairs, isString, trace, extend, UIRouter, StateService, UrlRouter, UrlMatcherFactory, ResolveContext,\n  unnestR, TypedMap\n} from \"@uirouter/core\";\nimport { ng1ViewsBuilder, getNg1ViewConfigFactory } from \"./statebuilders/views\";\nimport { TemplateFactory } from \"./templateFactory\";\nimport { StateProvider } from \"./stateProvider\";\nimport { getStateHookBuilder } from \"./statebuilders/onEnterExitRetain\";\nimport { Ng1LocationServices } from \"./locationServices\";\nimport { UrlRouterProvider } from \"./urlRouterProvider\";\nimport IInjectorService = angular.auto.IInjectorService; // tslint:disable-line\n\nangular.module(\"ui.router.angular1\", []);\nlet mod_init  = angular.module('ui.router.init',   []);\nlet mod_util  = angular.module('ui.router.util',   ['ng', 'ui.router.init']);\nlet mod_rtr   = angular.module('ui.router.router', ['ui.router.util']);\nlet mod_state = angular.module('ui.router.state',  ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nlet mod_main  = angular.module('ui.router',        ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nlet mod_cmpt  = angular.module('ui.router.compat', ['ui.router']); // tslint:disable-line\n\ndeclare module '@uirouter/core/lib/router' {\n  interface UIRouter {\n    /** @hidden */\n    stateProvider: StateProvider;\n    /** @hidden */\n    urlRouterProvider: UrlRouterProvider;\n  }\n}\n\nlet router: UIRouter = null;\n\n$uiRouter.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouter($locationProvider: ILocationProvider) {\n\n  // Create a new instance of the Router when the $uiRouterProvider is initialized\n  router = this.router = new UIRouter();\n  router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);\n\n  // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n  router.stateRegistry.decorator(\"views\",    ng1ViewsBuilder);\n  router.stateRegistry.decorator(\"onExit\",   getStateHookBuilder(\"onExit\"));\n  router.stateRegistry.decorator(\"onRetain\", getStateHookBuilder(\"onRetain\"));\n  router.stateRegistry.decorator(\"onEnter\",  getStateHookBuilder(\"onEnter\"));\n\n  router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());\n\n  let ng1LocationService = router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider);\n\n  Ng1LocationServices.monkeyPatchPathParameterType(router);\n\n  // backwards compat: also expose router instance as $uiRouterProvider.router\n  router['router'] = router;\n  router['$get'] = $get;\n  $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n  function $get($location: ILocationService, $browser: any, $sniffer: any, $rootScope: ng.IScope, $http: IHttpService, $templateCache: ITemplateCacheService) {\n    ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n    delete router['router'];\n    delete router['$get'];\n    return router;\n  }\n  return router;\n}\n\nconst getProviderFor = (serviceName) => [ '$uiRouterProvider', ($urp) => {\n  let service = $urp.router[serviceName];\n  service[\"$get\"] = () => service;\n  return service;\n}];\n\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector: IInjectorService, $q: IQService, $uiRouter: UIRouter) {\n  services.$injector = $injector;\n  services.$q = <any> $q;\n\n  // The $injector is now available.\n  // Find any resolvables that had dependency annotation deferred\n  $uiRouter.stateRegistry.get()\n      .map(x => x.$$state().resolvables)\n      .reduce(unnestR, [])\n      .filter(x => x.deps === \"deferred\")\n      .forEach(resolvable => resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi));\n}\n\n// $urlRouter service and $urlRouterProvider\nconst getUrlRouterProvider = (uiRouter: UIRouter) =>\n  uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter);\n\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nconst getStateProvider = () =>\n    extend(router.stateProvider, { $get: () => router.stateService });\n\nwatchDigests.$inject = ['$rootScope'];\nexport function watchDigests($rootScope: IRootScopeService) {\n  $rootScope.$watch(function() { trace.approximateDigests++; });\n}\n\nmod_init .provider(\"$uiRouter\",          <any> $uiRouter);\nmod_rtr  .provider('$urlRouter',         ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util .provider('$urlService',        getProviderFor('urlService'));\nmod_util .provider('$urlMatcherFactory', ['$uiRouterProvider', () => router.urlMatcherFactory]);\nmod_util .provider('$templateFactory',   () => new TemplateFactory());\nmod_state.provider('$stateRegistry',     getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals',   getProviderFor('globals'));\nmod_state.provider('$transitions',       getProviderFor('transitionService'));\nmod_state.provider('$state',             ['$uiRouterProvider', getStateProvider]);\n\nmod_state.factory ('$stateParams',       ['$uiRouter', ($uiRouter: UIRouter) => $uiRouter.globals.params]);\nmod_main .factory ('$view',              () => router.viewService);\nmod_main .service (\"$trace\",             () => trace);\n\nmod_main .run     (watchDigests);\nmod_util .run     (['$urlMatcherFactory', function ($urlMatcherFactory: UrlMatcherFactory) { }]);\nmod_state.run     (['$state', function ($state: StateService) { }]);\nmod_rtr  .run     (['$urlRouter', function ($urlRouter: UrlRouter) { }]);\nmod_init .run     (runBlock);\n\n/** @hidden TODO: find a place to move this */\nexport const getLocals = (ctx: ResolveContext): TypedMap<any> => {\n  let tokens = ctx.getTokens().filter(isString);\n\n  let tuples = tokens .map(key => {\n    let resolvable = ctx.getResolvable(key);\n    let waitPolicy = ctx.getPolicy(resolvable).async;\n    return [ key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data ];\n  });\n\n  return tuples.reduce(applyPairs, {});\n};\n\n","/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @ng1api\n * @preferred\n * @module directives\n */ /** for typedoc */\nimport { ng as angular } from \"../angular\";\nimport { IAugmentedJQuery, ITimeoutService, IScope, IInterpolateService } from \"angular\";\n\nimport {\n    Obj, extend, forEach, tail, isString, isObject, isArray, parse, noop, unnestR, identity, uniqR, inArray, removeFrom,\n    RawParams, PathNode, StateOrName, StateService, StateDeclaration, UIRouter\n} from \"@uirouter/core\";\nimport { UIViewData } from \"./viewDirective\";\n\n/** @hidden Used for typedoc */\nexport interface ng1_directive {}\n\n/** @hidden */\nfunction parseStateRef(ref: string) {\n  let paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (paramsOnly) ref = '(' + paramsOnly[1] + ')';\n\n  parsed = ref.replace(/\\n/g, \" \").match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n\n/** @hidden */\nfunction stateContext(el: IAugmentedJQuery) {\n  let $uiView: UIViewData = (el.parent() as IAugmentedJQuery).inheritedData('$uiView');\n  let path: PathNode[] = parse('$cfg.path')($uiView);\n  return path ? tail(path).state.name : undefined;\n}\n\n/** @hidden */\nfunction processedDef($state: StateService, $element: IAugmentedJQuery, def: Def): Def {\n  let uiState = def.uiState || $state.current.name;\n  let uiStateOpts = extend(defaultOpts($element, $state), def.uiStateOpts || {});\n  let href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n  return { uiState, uiStateParams: def.uiStateParams, uiStateOpts, href };\n}\n\n/** @hidden */\ninterface TypeInfo {\n  attr: string;\n  isAnchor: boolean;\n  clickable: boolean;\n}\n\n/** @hidden */\nfunction getTypeInfo(el: IAugmentedJQuery): TypeInfo {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\n/** @hidden */\nfunction clickHook(el: IAugmentedJQuery, $state: StateService, $timeout: ITimeoutService, type: TypeInfo, getDef: () => Def) {\n  return function (e: JQueryMouseEventObject) {\n    var button = e.which || e.button, target = getDef();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function () {\n        $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n\n      e.preventDefault = function () {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\n/** @hidden */\nfunction defaultOpts(el: IAugmentedJQuery, $state: StateService) {\n  return {\n    relative: stateContext(el) || $state.$current,\n    inherit: true,\n    source: \"sref\"\n  };\n}\n\n/** @hidden */\nfunction bindEvents(element: IAugmentedJQuery, scope: IScope, hookFn: (e: JQueryMouseEventObject) => void, uiStateOpts: any): void {\n  let events;\n\n  if (uiStateOpts) {\n    events = uiStateOpts.events;\n  }\n\n  if (!isArray(events)) {\n    events = ['click'];\n  }\n\n  let on = element.on ? 'on' : 'bind';\n  for (let event of events) {\n    element[on](event, hookFn);\n  }\n\n  scope.$on('$destroy', function() {\n    let off = element.off ? 'off' : 'unbind';\n    for (let event of events) {\n      element[off](event, hookFn);\n    }\n  });\n}\n\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nlet uiSref: ng1_directive;\nuiSref = ['$uiRouter', '$timeout',\n  function $StateRefDirective($uiRouter: UIRouter, $timeout: ITimeoutService) {\n    let $state = $uiRouter.stateService;\n\n    return {\n      restrict: 'A',\n      require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n      link: function (scope: IScope, element: IAugmentedJQuery, attrs: any, uiSrefActive: any) {\n        let type = getTypeInfo(element);\n        let active = uiSrefActive[1] || uiSrefActive[0];\n        let unlinkInfoFn: Function = null;\n        let hookFn;\n\n        let rawDef = {} as Def;\n        let getDef = () => processedDef($state, element, rawDef);\n\n        let ref = parseStateRef(attrs.uiSref);\n        rawDef.uiState = ref.state;\n        rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n\n        function update() {\n          let def = getDef();\n          if (unlinkInfoFn) unlinkInfoFn();\n          if (active) unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n          if (def.href != null) attrs.$set(type.attr, def.href);\n        }\n\n        if (ref.paramExpr) {\n          scope.$watch(ref.paramExpr, function (val) {\n            rawDef.uiStateParams = extend({}, val);\n            update();\n          }, true);\n          rawDef.uiStateParams = extend({}, scope.$eval(ref.paramExpr));\n        }\n\n        update();\n\n        scope.$on('$destroy', <any> $uiRouter.stateRegistry.onStatesChanged(update));\n        scope.$on('$destroy', <any> $uiRouter.transitionService.onSuccess({}, update));\n\n        if (!type.clickable) return;\n        hookFn = clickHook(element, $state, $timeout, type, getDef);\n        bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n      }\n    };\n  }];\n\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nlet uiState: ng1_directive;\nuiState = ['$uiRouter', '$timeout',\n  function $StateRefDynamicDirective($uiRouter: UIRouter, $timeout: ITimeoutService) {\n    let $state = $uiRouter.stateService;\n\n    return {\n      restrict: 'A',\n      require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n      link: function (scope: IScope, element: IAugmentedJQuery, attrs: any, uiSrefActive: any) {\n        let type = getTypeInfo(element);\n        let active = uiSrefActive[1] || uiSrefActive[0];\n        let unlinkInfoFn: Function = null;\n        let hookFn;\n\n        let rawDef = {} as Def;\n        let getDef = () => processedDef($state, element, rawDef);\n\n        let inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n        let watchDeregFns = inputAttrs.reduce((acc, attr) => (acc[attr] = noop, acc), {});\n\n        function update() {\n          let def = getDef();\n          if (unlinkInfoFn) unlinkInfoFn();\n          if (active) unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n          if (def.href != null) attrs.$set(type.attr, def.href);\n        }\n\n        inputAttrs.forEach((field) => {\n          rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n\n          attrs.$observe(field, (expr) => {\n            watchDeregFns[field]();\n            watchDeregFns[field] = scope.$watch(expr, (newval) => {\n              rawDef[field] = newval;\n              update();\n            }, true);\n          })\n        });\n\n        update();\n\n        scope.$on('$destroy', <any> $uiRouter.stateRegistry.onStatesChanged(update));\n        scope.$on('$destroy', <any> $uiRouter.transitionService.onSuccess({}, update));\n\n        if (!type.clickable) return;\n        hookFn = clickHook(element, $state, $timeout, type, getDef);\n        bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n      }\n    };\n  }];\n\n\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the <div> and <a> elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nlet uiSrefActive: ng1_directive;\nuiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n  function $StateRefActiveDirective($state: StateService, $stateParams: Obj, $interpolate: IInterpolateService, $uiRouter: UIRouter) {\n    return {\n      restrict: \"A\",\n      controller: ['$scope', '$element', '$attrs',\n        function ($scope: IScope, $element: IAugmentedJQuery, $attrs: any) {\n          let states: StateData[] = [],\n              activeEqClass: string,\n              uiSrefActive: any;\n\n          // There probably isn't much point in $observing this\n          // uiSrefActive and uiSrefActiveEq share the same directive object with some\n          // slight difference in logic routing\n          activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n          try {\n            uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n          } catch (e) {\n            // Do nothing. uiSrefActive is not a valid expression.\n            // Fall back to using $interpolate below\n          }\n          uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n          if (isObject(uiSrefActive)) {\n            forEach(uiSrefActive, function (stateOrName: StateOrName, activeClass: string) {\n              if (isString(stateOrName)) {\n                let ref = parseStateRef(stateOrName);\n                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n              }\n            });\n          }\n\n          // Allow uiSref to communicate with uiSrefActive[Equals]\n          this.$$addStateInfo = function (newState: string, newParams: Obj) {\n            // we already got an explicit state provided by ui-sref-active, so we\n            // shadow the one that comes from ui-sref\n            if (isObject(uiSrefActive) && states.length > 0) {\n              return;\n            }\n            let deregister = addState(newState, newParams, uiSrefActive);\n            update();\n            return deregister;\n          };\n\n          function updateAfterTransition(trans) {\n            trans.promise.then(update, noop);\n          }\n\n          $scope.$on('$stateChangeSuccess', update);\n          $scope.$on('$destroy', <any> $uiRouter.transitionService.onStart({}, updateAfterTransition));\n          if ($uiRouter.globals.transition) {\n            updateAfterTransition($uiRouter.globals.transition);\n          }\n\n          function addState(stateName: string, stateParams: Obj, activeClass: string) {\n            var state = $state.get(stateName, stateContext($element));\n\n            var stateInfo = {\n              state: state || { name: stateName },\n              params: stateParams,\n              activeClass: activeClass\n            };\n\n            states.push(stateInfo);\n\n            return function removeState() {\n              removeFrom(states)(stateInfo);\n            }\n          }\n\n          // Update route state\n          function update() {\n            const splitClasses = str =>\n                str.split(/\\s/).filter(identity);\n            const getClasses = (stateList: StateData[]) =>\n                stateList.map(x => x.activeClass).map(splitClasses).reduce(unnestR, []);\n\n            let allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(uniqR, []);\n            let fuzzyClasses = getClasses(states.filter(x => $state.includes(x.state.name, x.params)));\n            let exactlyMatchesAny = !!states.filter(x => $state.is(x.state.name, x.params)).length;\n            let exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n\n            let addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);\n            let removeClasses = allClasses.filter(cls => !inArray(addClasses, cls));\n\n            $scope.$evalAsync(() => {\n              addClasses.forEach(className => $element.addClass(className));\n              removeClasses.forEach(className => $element.removeClass(className));\n            });\n          }\n\n          update();\n        }]\n    };\n  }];\n\n/** @hidden */\ninterface Def { uiState: string; href: string; uiStateParams: Obj; uiStateOpts: any; }\n/** @hidden */\ninterface StateData { state: StateDeclaration; params: RawParams; activeClass: string; }\n\nangular.module('ui.router.state')\n    .directive('uiSref', uiSref)\n    .directive('uiSrefActive', uiSrefActive)\n    .directive('uiSrefActiveEq', uiSrefActive)\n    .directive('uiState', uiState);\n","/** @module ng1 */ /** for typedoc */\n\nimport { ng as angular } from \"./angular\";\nimport { Obj, StateService, StateOrName } from \"@uirouter/core\";\n\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nexport function $IsStateFilter($state: StateService) {\n  var isFilter: any = function(state: StateOrName, params: Obj, options?: { relative?: StateOrName }) {\n    return $state.is(state, params, options);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nexport function $IncludedByStateFilter($state: StateService) {\n  var includesFilter: any = function(state: StateOrName, params: Obj, options: { relative?: StateOrName }) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n","/** \n * @ng1api \n * @module directives \n */ /** for typedoc */\nimport { ng as angular } from \"../angular\";\nimport {\n    IInterpolateService, IScope, ITranscludeFunction, IAugmentedJQuery,\n    ICompileService, IControllerService, ITimeoutService, noop\n} from \"angular\";\n\nimport {\n    extend, unnestR, filter, tail, isDefined, isFunction, isString, trace, parse,\n    ActiveUIView, TransitionService, ResolveContext, Transition, PathNode, StateDeclaration,\n    Param, kebobString, HookRegOptions, ViewService, $QLike, Obj, TypedMap\n} from \"@uirouter/core\";\nimport {Ng1ViewConfig} from \"../statebuilders/views\";\nimport {Ng1Controller, Ng1StateDeclaration} from \"../interface\";\nimport {getLocals} from \"../services\";\nimport { ng1_directive } from \"./stateDirectives\";\n\n/** @hidden */\nexport type UIViewData = {\n  $cfg: Ng1ViewConfig;\n  $uiView: ActiveUIView;\n}\n\n/** @hidden */\nexport type UIViewAnimData = {\n  $animEnter: Promise<any>;\n  $animLeave: Promise<any>;\n  $$animLeave: { resolve: () => any; } // \"deferred\"\n}\n\n/**\n * `ui-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n *   Uses [[$uiViewScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n *\n * <!-- Named (different style) -->\n * <ui-view name=\"viewName\"></ui-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ui-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\nexport let uiView: ng1_directive;\nuiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\nfunction $ViewDirective($view: ViewService, $animate: any, $uiViewScroll: any, $interpolate: IInterpolateService, $q: $QLike) {\n\n  function getRenderer(attrs: Obj, scope: IScope) {\n    return {\n      enter: function(element: JQuery, target: any, cb: Function) {\n        if (angular.version.minor > 2) {\n          $animate.enter(element, null, target).then(cb);\n        } else {\n          $animate.enter(element, null, target, cb);\n        }\n      },\n      leave: function(element: JQuery, cb: Function) {\n        if (angular.version.minor > 2) {\n          $animate.leave(element).then(cb);\n        } else {\n          $animate.leave(element, cb);\n        }\n      }\n    };\n  }\n\n  function configsEqual(config1: Ng1ViewConfig, config2: Ng1ViewConfig) {\n    return config1 === config2;\n  }\n\n  let rootData = {\n    $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n    $uiView: { }\n  };\n\n  let directive = {\n    count: 0,\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement: JQuery, tAttrs: Obj, $transclude: ITranscludeFunction) {\n\n      return function (scope: IScope, $element: IAugmentedJQuery, attrs: Obj) {\n        let previousEl: JQuery, currentEl: JQuery,\n            currentScope: IScope, unregister: Function,\n            onloadExp     = attrs['onload'] || '',\n            autoScrollExp = attrs['autoscroll'],\n            renderer      = getRenderer(attrs, scope),\n            viewConfig    = undefined as Ng1ViewConfig,\n            inherited     = $element.inheritedData('$uiView') || rootData,\n            name          = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n\n        let activeUIView: ActiveUIView = {\n          $type: 'ng1',\n          id: directive.count++,                                   // Global sequential ID for ui-view tags added to DOM\n          name: name,                                              // ui-view name (<div ui-view=\"name\"></div>\n          fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name, // fully qualified name, describes location in DOM\n          config: null,                                            // The ViewConfig loaded (from a state.views definition)\n          configUpdated: configUpdatedCallback,                    // Called when the matching ViewConfig changes\n          get creationContext() {                                  // The context in which this ui-view \"tag\" was created\n            let fromParentTagConfig = parse('$cfg.viewDecl.$context')(inherited);\n            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n            // See https://github.com/angular-ui/ui-router/issues/3355\n            let fromParentTag = parse('$uiView.creationContext')(inherited);\n            return fromParentTagConfig || fromParentTag;\n          }\n        };\n\n        trace.traceUIViewEvent(\"Linking\", activeUIView);\n\n        function configUpdatedCallback(config?: Ng1ViewConfig) {\n          if (config && !(config instanceof Ng1ViewConfig)) return;\n          if (configsEqual(viewConfig, config)) return;\n          trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n\n          viewConfig = config;\n          updateView(config);\n        }\n\n        $element.data('$uiView', { $uiView: activeUIView });\n\n        updateView();\n\n        unregister = $view.registerUIView(activeUIView);\n        scope.$on(\"$destroy\", function() {\n          trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n          unregister();\n        });\n\n        function cleanupLastView() {\n          if (previousEl) {\n            trace.traceUIViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            let _viewData = currentEl.data('$uiViewAnim');\n            trace.traceUIViewEvent(\"Animate out\", _viewData);\n            renderer.leave(currentEl, function() {\n              _viewData.$$animLeave.resolve();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(config?: Ng1ViewConfig) {\n          let newScope = scope.$new();\n          let animEnter = $q.defer(), animLeave = $q.defer();\n\n          let $uiViewData: UIViewData = {\n            $cfg: config,\n            $uiView: activeUIView,\n          };\n\n          let $uiViewAnim: UIViewAnimData = {\n            $animEnter: animEnter.promise,\n            $animLeave: animLeave.promise,\n            $$animLeave: animLeave\n          };\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          let cloned = $transclude(newScope, function(clone) {\n            clone.data('$uiViewAnim', $uiViewAnim);\n            clone.data('$uiView', $uiViewData);\n            renderer.enter(clone, $element, function onUIViewEnter() {\n              animEnter.resolve();\n              if (currentScope) currentScope.$emit('$viewContentAnimationEnded');\n\n              if (isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n\n            cleanupLastView();\n          });\n\n          currentEl = cloned;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit('$viewContentLoaded', config || viewConfig);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}];\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile: angular.ICompileService,\n                            $controller: angular.IControllerService,\n                            $transitions: TransitionService,\n                            $view: ViewService,\n                            $q: angular.IQService,\n                            $timeout: ITimeoutService) {\n  const getControllerAs = parse('viewDecl.controllerAs');\n  const getResolveAs = parse('viewDecl.resolveAs');\n\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement: JQuery) {\n      let initial = tElement.html();\n      tElement.empty();\n\n      return function (scope: IScope, $element: JQuery) {\n        let data: UIViewData = $element.data('$uiView');\n        if (!data) {\n            $element.html(initial);\n            $compile($element.contents())(scope);\n            return;\n        }\n\n        let cfg: Ng1ViewConfig = data.$cfg || <any> { viewDecl: {}, getTemplate: noop };\n        let resolveCtx: ResolveContext = cfg.path && new ResolveContext(cfg.path);\n        $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n        trace.traceUIViewFill(data.$uiView, $element.html());\n\n        let link = $compile($element.contents());\n        let controller = cfg.controller;\n        let controllerAs: string = getControllerAs(cfg);\n        let resolveAs: string = getResolveAs(cfg);\n        let locals = resolveCtx && getLocals(resolveCtx);\n\n        scope[resolveAs] = locals;\n\n        if (controller) {\n          let controllerInstance = <Ng1Controller> $controller(controller, extend({}, locals, { $scope: scope, $element: $element }));\n          if (controllerAs) {\n            scope[controllerAs] = controllerInstance;\n            scope[controllerAs][resolveAs] = locals;\n          }\n\n          // TODO: Use $view service as a central point for registering component-level hooks\n          // Then, when a component is created, tell the $view service, so it can invoke hooks\n          // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n          // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n\n          $element.data('$ngControllerController', controllerInstance);\n          $element.children().data('$ngControllerController', controllerInstance);\n\n          registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n        }\n\n        // Wait for the component to appear in the DOM\n        if (isString(cfg.viewDecl.component)) {\n          let cmp = cfg.viewDecl.component;\n          let kebobName = kebobString(cmp);\n          let tagRegexp = new RegExp(`^(x-|data-)?${kebobName}$`, \"i\");\n\n          let getComponentController = () => {\n            let directiveEl = [].slice.call($element[0].children)\n                .filter((el: Element) => el && el.tagName && tagRegexp.exec(el.tagName)) ;\n            \n            return directiveEl && angular.element(directiveEl).data(`$${cmp}Controller`);\n          };\n\n          let deregisterWatch = scope.$watch(getComponentController, function(ctrlInstance) {\n            if (!ctrlInstance) return;\n            registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n            deregisterWatch();\n          });\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/** @hidden */\nlet hasComponentImpl = typeof (angular as any).module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nlet _uiCanExitId = 0;\n\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q: angular.IQService,\n                                     $transitions: TransitionService,\n                                     controllerInstance: Ng1Controller,\n                                     $scope: IScope,\n                                     cfg: Ng1ViewConfig) {\n  // Call $onInit() ASAP\n  if (isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n    controllerInstance.$onInit();\n  }\n\n  let viewState: Ng1StateDeclaration = tail(cfg.path).state.self;\n\n  let hookOptions: HookRegOptions = { bind: controllerInstance };\n  // Add component-level hook for onParamsChange\n  if (isFunction(controllerInstance.uiOnParamsChanged)) {\n    let resolveContext: ResolveContext = new ResolveContext(cfg.path);\n    let viewCreationTrans = resolveContext.getResolvable('$transition$').data;\n\n    // Fire callback on any successful transition\n    const paramsUpdated = ($transition$: Transition) => {\n      // Exit early if the $transition$ is the same as the view was created within.\n      // Exit early if the $transition$ will exit the state the view is for.\n      if ($transition$ === viewCreationTrans || $transition$.exiting().indexOf(viewState as StateDeclaration) !== -1) return;\n\n      let toParams = $transition$.params(\"to\") as TypedMap<any>;\n      let fromParams = $transition$.params<TypedMap<any>>(\"from\") as TypedMap<any>;\n      let toSchema: Param[] = $transition$.treeChanges().to.map((node: PathNode) => node.paramSchema).reduce(unnestR, []);\n      let fromSchema: Param[] = $transition$.treeChanges().from.map((node: PathNode) => node.paramSchema).reduce(unnestR, []);\n\n      // Find the to params that have different values than the from params\n      let changedToParams = toSchema.filter((param: Param) => {\n        let idx = fromSchema.indexOf(param);\n        return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n      });\n\n      // Only trigger callback if a to param has changed or is new\n      if (changedToParams.length) {\n        let changedKeys: string[] = changedToParams.map(x => x.id);\n        // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n        let newValues = filter(toParams, (val, key) => changedKeys.indexOf(key) !== -1);\n        controllerInstance.uiOnParamsChanged(newValues, $transition$);\n      }\n    };\n    $scope.$on('$destroy', <any> $transitions.onSuccess({}, paramsUpdated, hookOptions));\n  }\n\n  // Add component-level hook for uiCanExit\n  if (isFunction(controllerInstance.uiCanExit)) {\n    let id = _uiCanExitId++;\n    let cacheProp = '_uiCanExitIds';\n\n    // Returns true if a redirect transition already answered truthy\n    const prevTruthyAnswer = (trans: Transition) =>\n        !!trans && (trans[cacheProp] && trans[cacheProp][id] === true || prevTruthyAnswer(trans.redirectedFrom()));\n\n    // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n    const wrappedHook = (trans: Transition) => {\n      let promise, ids = trans[cacheProp] = trans[cacheProp] || {};\n      if (!prevTruthyAnswer(trans)) {\n        promise = $q.when(controllerInstance.uiCanExit(trans));\n        promise.then(val => ids[id] = (val !== false));\n      }\n      return promise;\n    };\n\n    let criteria = {exiting: viewState.name};\n    $scope.$on('$destroy', <any> $transitions.onBefore(criteria, wrappedHook, hookOptions));\n  }\n}\n\nangular.module('ui.router.state').directive('uiView', <any> uiView);\nangular.module('ui.router.state').directive('uiView', <any> $ViewDirectiveFill);\n","/** @module ng1 */ /** */\nimport { ng as angular } from \"./angular\";\nimport { IServiceProviderFactory } from \"angular\";\nimport IAnchorScrollService = angular.IAnchorScrollService;\nimport ITimeoutService = angular.ITimeoutService;\n\nexport interface UIViewScrollProvider {\n  /**\n   * Uses standard anchorScroll behavior\n   *\n   * Reverts [[$uiViewScroll]] back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n   * service for scrolling based on the url anchor.\n   */\n  useAnchorScroll(): void;\n}\n\n\n/** @hidden */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll: IAnchorScrollService, $timeout: ITimeoutService): Function {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element: JQuery) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', <IServiceProviderFactory> $ViewScrollProvider);\n","/**\n * @hidden\n * @module ng1\n */ /** */\ndeclare var angular;\nimport * as ng_from_import from \"angular\";\nlet ng_from_global = angular;\n\nexport const ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n","/** @module ng1 */ /** for typedoc */\nimport {\n    val, isObject, createProxyFunctions, BuilderFunction, StateRegistry, StateService, OnInvalidCallback\n} from \"@uirouter/core\";\nimport { Ng1StateDeclaration } from \"./interface\";\n\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nexport class StateProvider {\n  constructor(private stateRegistry: StateRegistry, private stateService: StateService) {\n    createProxyFunctions(val(StateProvider.prototype), this, val(this));\n  }\n\n  /**\n   * Decorates states when they are registered\n   *\n   * Allows you to extend (carefully) or override (at your own peril) the\n   * `stateBuilder` object used internally by [[StateRegistry]].\n   * This can be used to add custom functionality to ui-router,\n   * for example inferring templateUrl based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new\n   * properties within the state's internal definition. There is currently no clear\n   * use-case for this beyond accessing internal states (i.e. $state.$current),\n   * however, expect this to become increasingly relevant as we introduce additional\n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of\n   * execution of the builder functions in non-deterministic. Builder functions\n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to\n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view\n   *   name (i.e. \"viewName@stateName\") and each value is the config object\n   *   (template, controller) for the view. Even when you don't use the views object\n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template\n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state,\n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state.\n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that\n   *   would pass a `$state.includes()` test.\n   *\n   * #### Example:\n   * Override the internal 'views' builder with a function that takes the state\n   * definition, and a reference to the internal function being overridden:\n   * ```js\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   let result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     let autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   * ```\n   *\n   *\n   * ```js\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * $state.go('home');\n   * ```\n   *\n   * @param {string} name The name of the builder function to decorate.\n   * @param {object} func A function that is responsible for decorating the original\n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  decorator(name: string, func: BuilderFunction) {\n    return this.stateRegistry.decorator(name, func) || this;\n  }\n\n  /**\n   * Registers a state\n   *\n   * ### This is a passthrough to [[StateRegistry.register]].\n   *\n   * Registers a state configuration under a given state name.\n   * The stateConfig object has the following acceptable properties.\n   *\n   * <a id='template'></a>\n   *\n   * - **`template`** - {string|function=} - html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property\n   *   takes precedence over templateUrl.\n   *\n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <a id='templateUrl'></a>\n   *\n   * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *\n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <a id='templateProvider'></a>\n   *\n   * - **`templateProvider`** - {function=} - Provider function that returns HTML content\n   *   string.\n   *\n   * <a id='controller'></a>\n   *\n   * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *\n   * <a id='controllerProvider'></a>\n   *\n   * - **`controllerProvider`** - {function=} - Injectable provider function that returns\n   *   the actual controller or string.\n   *\n   * <a id='controllerAs'></a>\n   *\n   * - **`controllerAs`**  {string=}  A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   *\n   * <a id='resolve'></a>\n   *\n   * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises,\n   *   the router will wait for them all to be resolved or one to be rejected before the\n   *   controller is instantiated. If all the promises are resolved successfully, the values\n   *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any\n   *   of the promises are rejected the $stateChangeError event is fired. The map object is:\n   *\n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function,\n   *     it is injected and return value it treated as dependency. If result is a promise, it is\n   *     resolved before its value is injected into controller.\n   *\n   * <a id='url'></a>\n   *\n   * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any\n   *   parameters that were passed.\n   *\n   * <a id='params'></a>\n   *\n   * - **`params`** - {object=} - An array of parameter names or regular expressions. Only\n   *   use this within a state if you are not using url. Otherwise you can specify your\n   *   parameters within the url. When a state is navigated or transitioned to, the\n   *   $stateParams service will be populated with any parameters that were passed.\n   *\n   * <a id='views'></a>\n   *\n   * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\n   *   manually/explicitly.\n   *\n   * <a id='abstract'></a>\n   *\n   * - **`abstract`** - {boolean=} - An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   *\n   * <a id='onEnter'></a>\n   *\n   * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n   *\n   * <a id='onExit'></a>\n   *\n   * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n   *\n   * <a id='reloadOnSearch'></a>\n   *\n   * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()).\n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   *\n   * <a id='data'></a>\n   *\n   * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\n   *\n   * #### Example:\n   * Some state name examples\n   * ```js\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * ```\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} definition State configuration object.\n   */\n  state(name: string, definition: Ng1StateDeclaration): StateProvider;\n  state(definition: Ng1StateDeclaration): StateProvider;\n  state(name: any, definition?: any) {\n    if (isObject(name)) {\n      definition = name;\n    } else {\n      definition.name = name;\n    }\n    this.stateRegistry.register(definition);\n    return this;\n  }\n\n  /**\n   * Registers an invalid state handler\n   *\n   * This is a passthrough to [[StateService.onInvalid]] for ng1.\n   */\n\n  onInvalid(callback: OnInvalidCallback): Function {\n    return this.stateService.onInvalid(callback);\n  }\n}\n","/** @module ng1 */ /** */\nimport {\n  StateObject, TransitionStateHookFn, HookResult, Transition, services, ResolveContext, extend, BuilderFunction\n} from \"@uirouter/core\";\nimport { getLocals } from \"../services\";\nimport { Ng1StateDeclaration } from '../interface';\n\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n */\nexport const getStateHookBuilder = (hookName: \"onEnter\"|\"onExit\"|\"onRetain\") =>\nfunction stateHookBuilder(state: StateObject, parentFn: BuilderFunction): TransitionStateHookFn {\n  let hook = state[hookName];\n  let pathname = hookName === 'onExit' ? 'from' : 'to';\n\n  function decoratedNg1Hook(trans: Transition, state: Ng1StateDeclaration): HookResult {\n    let resolveContext = new ResolveContext(trans.treeChanges(pathname));\n    let locals = extend(getLocals(resolveContext), { $state$: state, $transition$: trans });\n    return services.$injector.invoke(hook, this, locals);\n  }\n\n  return hook ? decoratedNg1Hook : undefined;\n};\n","/**\n * @internalapi\n * @module ng1\n */ /** */\nimport { LocationConfig, LocationServices, UIRouter, ParamType } from \"@uirouter/core\";\nimport { val, createProxyFunctions, removeFrom, isObject } from \"@uirouter/core\";\nimport { ILocationService, ILocationProvider } from \"angular\";\n\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n */\nexport class Ng1LocationServices implements LocationConfig, LocationServices {\n  private $locationProvider: ILocationProvider;\n  private $location: ILocationService;\n  private $sniffer;\n\n  path;\n  search;\n  hash;\n  hashPrefix;\n  port;\n  protocol;\n  host;\n  baseHref;\n\n  // .onChange() registry\n  private _urlListeners: Function[] = [];\n\n  dispose() { }\n\n  constructor($locationProvider: ILocationProvider) {\n    this.$locationProvider = $locationProvider;\n    let _lp = val($locationProvider);\n    createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n  }\n\n  onChange(callback: Function) {\n    this._urlListeners.push(callback);\n    return () => removeFrom(this._urlListeners)(callback);\n  }\n\n  html5Mode() {\n    let html5Mode: any = this.$locationProvider.html5Mode();\n    html5Mode = isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n    return html5Mode && this.$sniffer.history;\n  }\n\n  url(newUrl?: string, replace = false, state?) {\n    if (newUrl) this.$location.url(newUrl);\n    if (replace) this.$location.replace();\n    if (state) this.$location.state(state);\n    return this.$location.url();\n  }\n\n  _runtimeServices($rootScope, $location: ILocationService, $sniffer, $browser) {\n    this.$location = $location;\n    this.$sniffer = $sniffer;\n\n    // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n    $rootScope.$on(\"$locationChangeSuccess\", evt => this._urlListeners.forEach(fn => fn(evt)));\n    let _loc = val($location);\n    let _browser = val($browser);\n\n    // Bind these LocationService functions to $location\n    createProxyFunctions(_loc, this, _loc, [\"replace\", \"path\", \"search\", \"hash\"]);\n    // Bind these LocationConfig functions to $location\n    createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n    // Bind these LocationConfig functions to $browser\n    createProxyFunctions(_browser, this, _browser, ['baseHref']);\n  }\n\n  /**\n   * Applys ng1-specific path parameter encoding\n   *\n   * The Angular 1 `$location` service is a bit weird.\n   * It doesn't allow slashes to be encoded/decoded bi-directionally.\n   *\n   * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n   *\n   * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n   *\n   * @param router\n   */\n  static monkeyPatchPathParameterType(router: UIRouter) {\n    let pathType: ParamType = router.urlMatcherFactory.type('path');\n\n    pathType.encode = (val: any) =>\n        val != null ? val.toString().replace(/(~|\\/)/g, m => ({ '~': '~~', '/': '~2F' }[m])) : val;\n\n    pathType.decode = (val: string) =>\n        val != null ? val.toString().replace(/(~~|~2F)/g, m => ({ '~~': '~', '~2F': '/' }[m])) : val;\n\n  }\n}\n","/** @module url */ /** */\nimport {\n    UIRouter, UrlRouter, LocationServices, $InjectorLike, BaseUrlRule, UrlRuleHandlerFn, UrlMatcher,\n    IInjectable\n} from \"@uirouter/core\";\nimport { services, isString, isFunction, isArray, identity } from \"@uirouter/core\";\n\nexport interface RawNg1RuleFunction {\n  ($injector: $InjectorLike, $location: LocationServices): string|void;\n}\n\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @deprecated\n */\nexport class UrlRouterProvider {\n  /** @hidden */ _router: UIRouter;\n  /** @hidden */ _urlRouter: UrlRouter;\n\n  /** @hidden */\n  constructor(router: UIRouter) {\n    this._router = router;\n    this._urlRouter = router.urlRouter;\n  }\n\n  /** @hidden */\n  $get() {\n    let urlRouter = this._urlRouter;\n    urlRouter.update(true);\n    if (!urlRouter.interceptDeferred) urlRouter.listen();\n    return urlRouter;\n  }\n\n  /**\n   * Registers a url handler function.\n   *\n   * Registers a low level url handler (a `rule`).\n   * A rule detects specific URL patterns and returns a redirect, or performs some action.\n   *\n   * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n   *\n   * #### Example:\n   * ```js\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * ```\n   *\n   * @param ruleFn\n   * Handler function that takes `$injector` and `$location` services as arguments.\n   * You can use them to detect a url and return a different url as a string.\n   *\n   * @return [[UrlRouterProvider]] (`this`)\n   */\n  rule(ruleFn: RawNg1RuleFunction): UrlRouterProvider {\n    if (!isFunction(ruleFn)) throw new Error(\"'rule' must be a function\");\n\n    const match = () =>\n        ruleFn(services.$injector, this._router.locationService);\n\n    let rule = new BaseUrlRule(match, identity);\n    this._urlRouter.rule(rule);\n    return this;\n  };\n\n  /**\n   * Defines the path or behavior to use when no url can be matched.\n   *\n   * #### Example:\n   * ```js\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * ```\n   *\n   * @param rule\n   * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n   * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  otherwise(rule: string | RawNg1RuleFunction): UrlRouterProvider {\n    let urlRouter = this._urlRouter;\n\n    if (isString(rule)) {\n      urlRouter.otherwise(rule);\n    } else if (isFunction(rule)) {\n      urlRouter.otherwise(() => rule(services.$injector, this._router.locationService));\n    } else {\n      throw new Error(\"'rule' must be a string or function\");\n    }\n\n    return this;\n  };\n\n  /**\n   * Registers a handler for a given url matching.\n   *\n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable.\n   * It gets invoked if `$location` matches.\n   * You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * #### Example:\n   * ```js\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * ```\n   *\n   * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n   * @param handler The path (or function that returns a path) that you want to redirect your user to.\n   * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n   *\n   * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n   */\n  when(what: (RegExp|UrlMatcher|string), handler: string|IInjectable) {\n    if (isArray(handler) || isFunction(handler)) {\n      handler = UrlRouterProvider.injectableHandler(this._router, handler);\n    }\n\n    this._urlRouter.when(what, handler as any);\n    return this;\n  };\n\n  static injectableHandler(router: UIRouter, handler): UrlRuleHandlerFn {\n    return match =>\n        services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n  }\n\n  /**\n   * Disables monitoring of the URL.\n   *\n   * Call this method before UI-Router has bootstrapped.\n   * It will stop UI-Router from performing the initial url sync.\n   *\n   * This can be useful to perform some asynchronous initialization before the router starts.\n   * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n   *\n   * #### Example:\n   * ```js\n   * var app = angular.module('app', ['ui.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   $urlRouterProvider.deferIntercept();\n   * })\n   *\n   * app.run(function (MyService, $urlRouter, $http) {\n   *   $http.get(\"/stuff\").then(function(resp) {\n   *     MyService.doStuff(resp.data);\n   *     $urlRouter.listen();\n   *     $urlRouter.sync();\n   *   });\n   * });\n   * ```\n   *\n   * @param defer Indicates whether to defer location change interception.\n   *        Passing no parameter is equivalent to `true`.\n   */\n  deferIntercept(defer?: boolean) {\n    this._urlRouter.deferIntercept(defer);\n  };\n}\n","/**\n * Main entry point for angular 1.x build\n * @module ng1\n */ /** */\n\nexport * from \"./interface\";\nexport * from \"./services\";\nexport * from \"./statebuilders/views\";\nexport * from \"./stateProvider\";\nexport * from \"./urlRouterProvider\";\n\nimport \"./injectables\";\nimport \"./directives/stateDirectives\";\nimport \"./stateFilters\";\nimport \"./directives/viewDirective\";\nimport \"./viewScroll\";\n\nexport default \"ui.router\";\n\nimport * as core from \"@uirouter/core\";\nexport { core };\nexport * from \"@uirouter/core\";\n\n"],"names":["templateFactory","path","view","services","$injector","get","Ng1ViewConfig","state","parent","tplKeys","ctrlKeys","compKeys","nonCompKeys","concat","allViewKeys","isDefined","views","hasAnyKey","Error","name","filter","key","join","viewsObject","$default","pick","forEach","config","isString","component","extend","resolveAs","$type","$context","$name","normalized","ViewService","normalizeUIViewTarget","$uiViewName","uiViewName","$uiViewContextAnchor","uiViewContextAnchor","cmpDefs","length","map","getBindings","reduce","unnestR","$locationProvider","$location","$browser","$sniffer","$rootScope","$http","$templateCache","ng1LocationService","_runtimeServices","router","this","UIRouter","stateProvider","StateProvider","stateRegistry","stateService","decorator","ng1ViewsBuilder","getStateHookBuilder","viewService","_pluginapi","_viewConfigFactory","getNg1ViewConfigFactory","locationService","locationConfig","Ng1LocationServices","monkeyPatchPathParameterType","$get","$inject","$q","$uiRouter","x","$$state","resolvables","deps","resolvable","annotate","resolveFn","strictDi","$watch","trace","approximateDigests","ref","parsed","paramsOnly","match","replace","paramExpr","el","$uiView","inheritedData","parse","tail","undefined","$state","$element","def","uiState","current","uiStateOpts","defaultOpts","href","uiStateParams","isSvg","Object","prototype","toString","call","prop","isForm","nodeName","attr","isAnchor","toUpperCase","clickable","$timeout","type","getDef","e","button","which","target","ctrlKey","metaKey","shiftKey","transition","go","preventDefault","ignorePreventDefaultCount","cancel","relative","stateContext","$current","inherit","source","element","scope","hookFn","events","isArray","on","events_1","_i","event_1","$on","off","events_2","event_2","isFilter","params","options","is","$stateful","includesFilter","includes","$compile","$controller","$transitions","$view","getControllerAs","getResolveAs","restrict","priority","compile","tElement","initial","html","empty","data","contents","cfg","$cfg","viewDecl","getTemplate","noop","resolveCtx","ResolveContext","traceUIViewFill","link","controller","controllerAs","locals","getLocals","controllerInstance","$scope","children","registerControllerCallbacks","cmp_1","kebobName","kebobString","tagRegexp_1","RegExp","getComponentController","directiveEl","slice","tagName","exec","angular","deregisterWatch_1","ctrlInstance","isFunction","$onInit","hasComponentImpl","viewState","self","hookOptions","bind","uiOnParamsChanged","resolveContext","viewCreationTrans_1","getResolvable","paramsUpdated","$transition$","exiting","indexOf","toParams","fromParams","toSchema","treeChanges","to","node","paramSchema","fromSchema","from","changedToParams","param","idx","equals","id","changedKeys_1","newValues","val","onSuccess","uiCanExit","id_1","_uiCanExitId","prevTruthyAnswer_1","trans","redirectedFrom","wrappedHook","promise","ids","when","then","criteria","onBefore","useAnchorScroll","$anchorScroll","scrollIntoView","ng_from_global","ng","ng_from_import","ng_from_import.module","keys","obj","acc","factory","uiView","context","_this","makeComponentTemplate","bindings","template","paramValues","promises","fromConfig","getController","all","results","traceViewServiceEvent","provider","controllerProvider","isInjectable","providerFn","Resolvable","version","minor","$templateRequest","has","TemplateFactory","value","_useHttp","asTemplate","result","str","asComponent","fromString","templateUrl","fromUrl","templateProvider","fromProvider","componentProvider","fromComponentProvider","url","cache","headers","Accept","response","prefix","kebob","camelCase","kebobed","attributeTpl","input","attrName","resolveName","res","fn","args","attrs","getComponentBindings","scopeBindings","isObject","bindToController","bindingsObj","tuple","createProxyFunctions","func","definition","register","callback","onInvalid","hookName","parentFn","pathname","$state$","invoke","hook","decoratedNg1Hook","_lp","_urlListeners","push","removeFrom","html5Mode","enabled","history","newUrl","evt","_loc","_browser","pathType","urlMatcherFactory","encode","m","~","/","decode","~~","~2F","_router","_urlRouter","urlRouter","UrlRouterProvider","update","interceptDeferred","listen","ruleFn","rule","BaseUrlRule","identity","otherwise","what","handler","injectableHandler","$match","$stateParams","globals","defer","deferIntercept","module","mod_init","mod_util","mod_rtr","mod_state","mod_main","getProviderFor","serviceName","$urp","service","runBlock","getUrlRouterProvider","uiRouter","urlRouterProvider","getStateProvider","watchDigests","run","$urlMatcherFactory","$urlRouter","uiSref","ctx","getTokens","getPolicy","async","applyPairs","require","uiSrefActive","unlinkInfoFn","active","$$addStateInfo","$set","getTypeInfo","rawDef","processedDef","parseStateRef","uiSrefOpts","$eval","onStatesChanged","transitionService","clickHook","bindEvents","inputAttrs","watchDeregFns","field","$observe","expr","newval","$interpolate","$attrs","stateName","stateParams","activeClass","stateInfo","states","splitClasses","split","getClasses","stateList","allClasses","activeEqClass","uniqR","fuzzyClasses","exactlyMatchesAny","exactClasses","addClasses","removeClasses","cls","inArray","$evalAsync","className","addClass","removeClass","uiSrefActiveEq","stateOrName","addState","newState","newParams","deregister","onStart","updateAfterTransition","directive","$IsStateFilter","$IncludedByStateFilter","$animate","$uiViewScroll","enter","cb","leave","config1","config2","rootData","_rootViewContext","count","terminal","transclude","tAttrs","$transclude","configsEqual","viewConfig","traceUIViewConfigUpdated","activeUIView","updateView","previousEl","traceUIViewEvent","remove","currentScope","$destroy","currentEl","_viewData_1","renderer","$$animLeave","resolve","newScope","$new","animEnter","animLeave","$uiViewData","$uiViewAnim","$animEnter","$animLeave","$emit","cloned","clone","autoScrollExp","cleanupLastView","onloadExp","unregister","getRenderer","inherited","fqn","configUpdated","configUpdatedCallback","creationContext","fromParentTagConfig","fromParentTag","registerUIView","$ViewDirectiveFill","$ViewScrollProvider"],"mappings":"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"}